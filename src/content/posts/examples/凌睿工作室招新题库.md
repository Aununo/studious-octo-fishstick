---
title: 凌睿工作室招新题库
published: 2025-10-26T15:12:24.033Z
description: '一些和密码学有关的基础问题。'
updated: ''
tags:
  - Crypto
draft: true
pin: 0
toc: false
lang: 'zh'
abbrlink: ''
---

# Basic 1

> 敲打出题人：@xing4c

## Task 0 How markdown works?

### Background

回想起来，上一次招新 ~~还是在上一次~~ 好像也在二轮再次强调了基础。

首先，从 **使用 markdown** 编写你的题解开始。

答题格式：

- 使用 markdown 编写你的题解，并且将其导出为 pdf 提交。
- 写的时候记得善用 markdown 语法，让你的回答 **富有层次感**、**重点突出**。
- 公式应使用 LaTeX，并且注意 **正确使用数学符号的对应 LaTeX 公式**。文章中的数学符号应尽可能前后一致（因为你的回答可能会很长），并且应该使用标准的符号，让你的回答 **足够严谨**。
- 回答应该有充足的理由，不能仅仅给出答案。

为你准备的参考资料：

- [Markdown 基本语法 | Markdown 教程](https://markdown.com.cn/basic-syntax/)：学习如何书写 Markdown。
- [LaTeX 符号大全](https://zhuanlan.zhihu.com/p/472919794)、[常用数学符号的 LaTeX 表示方法](https://mohu.org/info/symbols/symbols.htm)：如何用 LaTeX 书写常见数学符号。

- [LaTeX 符号手写识别](https://detexify.kirelabs.org/classify.html)：不知道某个符号如何用 LaTeX 打出来，这里可以识别你的手写符号。
- [如何用 Markdown 和 LaTeX 写一篇排版整齐的题解？](https://help.luogu.com.cn/rules/academic/guide/solution)：学习良好的排版风格。

排版良好，格式正确的题解确实会给人好的印象，阅读起来也很方便。**格式与要求出现很大差别时，你的题解可能会被打回。**当然，由于大家需要一个熟悉的过程，一些小错误是可以接受的。

### Task 0 任务

Task 0 任务很简单，因为你后续所有的题目（包括本题）中，解题报告文档的提交，都要用 Task 0 教你的技术来完成啦！

## Task 1 How I learned to learn (crypto)?

### Background

我是如何学会学习（密码学）的？

学习的过程可能很艰难，不过没关系。我们要 **学会如何学习**，这比学习知识更重要。所以本题将会引导你学会如何学习（不止密码学）。当然，学无止境，我们能够提供的帮助也只是学习路上的一小部分罢了。

不得不否认的是，AI 确实很强大，正确地使用 AI 进行学习能极大提升我们学习的效率。我们鼓励大家 **合理使用** AI 来帮助自己学习。

但是我们也逐渐依赖 AI，让 AI 代替我们的大脑解决问题、思考分析...这不好。所以我们还需要一些更传统的方法，比如 **阅读博客**、**使用 google 等搜索引擎**、**阅读相关书籍与论文**、**查阅专门的网站** 等。

此外，学习时注意做好笔记。可能在未来，你会一次又一次打开之前的笔记，查阅你学习时的点滴心得。善用你在 Task 0 中学到的技术丰富你的笔记，方便后续的学习。

### Task 1 任务

Task 1 任务很简单，在完成 Task 2 之后，附上你在完成 Task 2 过程中用到的资料即可。比如，你查找的博客链接、阅读的书籍名字等。

## Task 2 What r u learning?

### Background

> 听说你在学密码学欸，你都学了些什么？
>
> 能给我讲讲吗，密码学的故事......

~~即使是挣扎于数论基础的初学者，一想到密码学的人类智慧，便会不由自主地挺起胸膛。~~

不管学的怎么样，别人问起来总得能稍微讲讲吧，密码学还是挺有意思的。不管是古典密码的斗智斗勇还是现代密码真正的人类智慧，都令人津津乐道。

还记得一轮的“***普通和理所当然是什么呢***”这道题吗？你还记得它讲了一个什么故事吗？从“普通”的对称加密，到“理所当然”的公钥加密，再到中间人攻击、数字签名与 CA，你能体会到这套机制的设计和演进过程吗？

当然，如果不了解也不要紧，现在开始也不迟。

### Task 2 任务

- 说明古典密码和现代密码的区别。
- 简单讲讲古典密码主要使用的技术，有哪些典型的古典密码。
  - 当然，不要花费过多精力在古典密码上，看个好玩就行。

> Hint：如果你时间充足，可以读读《密码故事》这本书，主要是读着玩。

- 简单讲讲现代密码的一些常见技术和原理，以及我们为什么这么做。

> Hint：可以参考一轮题目“普通和理所当然是什么呢”。

- 简单讲讲除了上面提到的技术之外，现代密码学还有哪些研究方向？都是干什么的？
- 学习了这么多之后，你对密码学是否有了进一步的理解？你的感受如何？
  - 简单讲讲就行，有啥说啥，没啥想法也没啥问题。

# Basic 1.5

> 敲打出题人：@xing4c

## Task 0 给我干哪来了

### Background

~~你们密码学怎么还有小数点作啊？~~

这份题目主要是学习进行一些必要工具的安装和使用，尽力完成对自己有好处，就算你自己以后不打算学密码学。~~我甚至觉得这个题目以后能当 Basic 给所有人做了。~~

### Task 0 任务

了解这一信息：本题目所有 Task 都没有强制提交的材料，自己边学边做，培养自己记录笔记的习惯，最后记了多少交多少即可。你觉得有的东西有必要记录就记下来，没必要记录的也不用嗯凑。

## Task 1 怎么密码学也要装 Linux

### Background

如题。如果你们看过后端的一轮题目的话，会有一个装 Linux 的题目。那可能有人很奇怪，我们不是密码学吗，也非得整一个？其实不管是什么方向，Linux 都是一个不可或缺的东西，它会让你在开发、学习等方面获得很大的便利！

比如其他的 flag 题中的 `nc` 命令，就是 `netcat` 工具，很多 Linux 发行版都自带。但是 Windows 没有，你可能需要额外安装，并且使用起来可能有一些区别。当然，还有更多命令行工具等你探索，你甚至可以装一个黑客一点的 Linux 发行版（当然也不一定非要这么做）。

所以咱也得整一个不是。

### Task 1 任务

于是老东西进入后台管理系统，把后端的题目薅过来了！他们的题目写的真不错呀... ~~我都想复制粘贴了~~ 我们这里就从简一点吧。

- 使用虚拟机或者 WSL 安装一个常见的 Linux 发行版。
- 学会连上你的 Linux 虚拟机或者 WSL。
- 学会使用 Linux 系统的基本命令、学会使用包管理器。
- 学会用 VS Code 连到你的虚拟机 / WSL。（SSH / Remote - WSL）
- 让你的 Linux 发行版使用代理，能够访问 google 等网站。（这很重要）

## Task 2 我要成为蟒蛇高手

### Background

~~都什么年代了，还在用传统编程语言~~

Python 是一种 **非常易用** 的编程语言，而且非常强大。密码学中很常用，就算你不学密码学了也能用得上。

可能初学者很难体会这一点，但是当你能够在有 idea 或者麻烦工作的时候，随手使用 Python 编写一个脚本解决这个问题，你就会感觉到它的方便之处了。比如，你需要写一个脚本批量处理你的文件，或者处理一个 Excel 表格，再或者给上千人批量发邮件...

再比如，在其他题中使用 pwntools 和服务器交互！所以说就当是为了做题也得学学，不是吗。

### Task 2 任务

- 安装 Python。
- 学会使用一款你喜欢的开发工具写 Python 代码。
- 学会 Python 的包管理，安装一些你用得上的库。
- 学会 Python 虚拟环境的使用，避免库冲突。

## Task 3 二次元（可选）

### Background

这个任务不做也可以，但是你也可以尝试尽自己的喜好做。

**需要注意的是这可能非常耗费你的精力和时间，尤其是没有相关经验和指引的情况下。你可能遇到很多问题，都需要你自己解决。**

~~你也可以戳出题人让他帮你，但是他不会优先处理这个，最多丢给你一些参考资料。~~

你可能完全不喜欢用终端和你刚装好的 Linux 交流，尤其是如果你装的 Linux 没有图形界面，你不得不通过终端访问时。

别着急，你慢慢就会习惯的。另外，你也可以尝试努力一下，喜欢上使用终端的感觉！~~想象一个典型的 Nerd 形象，对着一个闪烁着字符界面的终端，手在笔记本电脑的键盘上上下翻飞，眼前的终端不断有字符跳动，很符合我对黑客/极客/肥宅/MTF或者他们是一个人或者是一切充满刻板印象的群体的想象...~~

咳咳，言归正传。你的终端可能长这样的：

![](https://pic1.imgdb.cn/item/68d2bd27c5157e1a882bd7c1.png)

还就是那个傻大黑粗。而且很不好用。所以你不喜欢用是正常的，因为它本身确实没那么现代，也自然没那么方便。

但是你又看到了这个：

![](https://pic1.imgdb.cn/item/68d2bd28c5157e1a882bd7c4.png)

不对啊，这个终端怎么这么好看 ~~傻逼二次元~~？

而且看起来不同的文件有各种颜色和图标，很清楚。当然功能远远不止这一个，更多的实用功能还要靠大家自己探索。

### Task 3 任务

- 使用一款现代化的终端软件。
- 自己美化你的终端。
- 选择一个现代化的 Shell。
- 美化你的 Shell。
- 为你的 Shell 安装一些插件，让它更好用。
- 要是你还有精力装个 nvim 之类的东西，再把它配置的非常趁手 ~~然后吃灰~~，那你真的是大神 ~~无可救药~~ 了！
  - 一般来讲我们还是用 VS Code 之类的代码编辑器远程连接比较方便。
  - 当然配好了之后一些非常简单的代码或者文本编辑直接写也是挺舒适的。

### Task 3 Hint

- 记录自己的安装过程会很有帮助，方便查看问题出在哪里。
- 用别人的成熟配置也是一种明智的选择，比较流行的配置文件都留有自定义的空间，你也可以看懂配置文件之后自己进行个性化的修改，以适应你的需求。
- 永远先阅读大量的相关文章，至少在你决定跟着某一个教程之前，你需要把这个教程本身全文通读一遍，避免做到一半发现问题没办法解决的情况。
- Good luck and have fun!

# Basic 2

> 敲打出题人：@xing4c

## Task 0 你说这小玩意谁研究的呢.jpg

### Background

其实今年的 Basic 系列题目放到之前都是一道题呢（笑）。

今年拆开的话，希望能及时掌握大家的学习进度，此外更好地夯实大家的基础。也希望大家不要被题目数量吓退了，其实都是打基础，都是打基础.jpg

基础题里面，我们会接触到一些数学知识、公钥加密算法基础、数字签名基础，都是挺重要的知识，希望大家能尽力学习，内化于心。

### Task 0 任务

~~大喊：我——准备好了！~~

## Task 1 数学基础

### Background

> 『螺旋阶梯』！『独角仙』！『废墟街道』！『无花果塔』！『独角仙』！『苦伤道』！『独角仙』！『特异点』！『乔托』！『天使』！『绣球花』！『独角仙』！『特异点』！『秘密皇帝』！

学习以下知识，记录学习笔记。

- 算术基本定理、整除、同余、同余类、剩余系的基本定义。
- 费马小定理的内容、证明。
- 欧拉函数的定义、性质、求法及证明。
- 欧拉定理的内容、证明。
- 扩展欧拉定理的内容、证明。
- 快速幂算法。
- 裴蜀定理的内容、证明。
- 扩展欧几里得算法。
- 群论基础知识。
- 模数意义下的乘法群。
- 阶、循环群、生成元、原根。
- 逆元、求解逆元的方法。

我们为你准备了一些资料：

资料：

- [Dan Boneh的密码学课程](https://www.bilibili.com/video/BV1yx411T78i)
- [密码学的数学基础](https://www.bilibili.com/video/BV1bY411G7sY)
- [OI-Wiki](https://oi-wiki.org/)（比起看视频学习来说，可以先看这个）
- [CTF-Wiki](https://ctf-wiki.org/)
- 或者自行下载/借阅相关书籍。

### Task 1 任务

- 提交学习笔记。
- 对学习笔记的要求：假设你在给我讲解这些知识（并且假设我不会），**要把核心内容讲清楚，逻辑通顺，表达清晰，让原来不会的人看过讲解之后学会**。如果有自己的思考和想法也可以写出来，可能会得到额外奖励。

## Task 2 It's my code!!!!!

### Background

很多算法呢，你不仅需要掌握其内容，其算法的代码实现同样是重要的。

我们学习这些算法的代码实现，其实不是为了学写代码而已。更重要的是学习它的思想。

所以，请你编写代码，解决下面的问题吧！

- 分解质因数。
- 计算一个数的欧拉函数。
- 快速幂算法。
- 扩展欧几里得算法。
- 给定 $a,b$，求解同余方程 $ax \equiv 1 \pmod b$ 的最小正整数解。

### Task 2 任务

- 编写代码语言不限，当然不要直接调库。不管你用 C 或者 Python 写都行。
- 同时我们鼓励你直接调库，所以除了编写代码之外，你需要查找一下 Python 里面有什么库实现了这些算法，具体调库又该怎么调。
- 提交代码的方式：不需要你提交源代码，你要把代码以代码块形式写在你的 markdown 文档里。不清楚的话左转 markdown 语法。

# Basic 3

> 敲打出题人：@xing4c

## Task 0 放轻松

### Background

~~被数学基础蹂躏了吗~~

其实没那么困难，放轻松。

> 就是这样，
>
> 只需呼吸。
>
> 为什么你看起来如此紧张？

### Task 0 任务

> 你能做到。

## Task 1 年轻人的第一款公钥加密

### Background

RSA 应该是最出名的公钥算法了吧。就算你不学密码学，你也应该了解过 RSA，至少听说过。~~没有了解 RSA 的人生是一段相对失败的人生~~ 鉴于 RSA 算法知名度高、思想简单，于是它成为了人们喜闻乐见的公钥加密算法，也是大多数人学习公钥加密算法的第一课。

### Task 1 任务

讲解 RSA 算法：

- 公钥和私钥的生成；
- 加密、解密的过程及原理；
- RSA 算法的安全性。

## Task 2 俺寻思

### Background

我很好奇，如果使用三个大质数相乘作为模数会发生什么。

### Task 2 任务

请判断这些说法的正确性，并给出理由：

- 如果找到了模数 $n$ 的一个因数 $p$，那么破解密文的难度退化为与破解 RSA 相当。
- 这个算法使用三个大质数相乘会导致加密解密出错。
- 在 $n$ 长度相当的情况下，使用更多的质数相乘，这个升级版的 RSA 更安全。

## Task 3 要不咱试试呢？

### Background

~~有一天，你的 npy 给了你 ta 服务器的 ip、用户和私钥，但是你却不知道如何登陆 ta 的服务器，真是可惜啊。~~

~~有一天，你的 npy 要你把你服务器的信息给 ta，让 ta 能登上去，但是你却不知道给 ta 什么，真是可惜啊。~~

其实 RSA 离你并不遥远。

比如，你现在就能随手生成一个 RSA 密钥，然后自己保管好私钥，并把公钥放到你的服务器上，用于免密 ssh 登录到你的服务器。

当然，你可能没有一个服务器，不过没关系。你还有很多种方法进行模拟体验。

### Task 3 任务

- 使用 OpenSSH 生成一个 RSA 密钥对。
  - Hint：`ssh-keygen -t rsa -b 4096 -C "your_email@example.com" -f ~/.ssh/id_rsa`

- 把公钥保存到远程服务器。私钥自己留存好。
  - 如果你没有远程服务器，可以用本机模拟，或者用你的 Linux 虚拟机 / WSL 模拟，或者使用 Docker 容器起一个 SSH 服务~~（你都会用 Docker 了那这个肯定难不倒你）~~
  - Hint：问 AI 或者搜一些博客或者直接找云服务厂商提供的帮助文档。
- 尝试 ssh 登陆你的远程服务器。
- 通过上面的步骤，你应该能体会真实情境下公钥加密技术的应用。记录操作步骤，注意保存每步的截图。

# Basic 4

> 敲打出题人：@xing4c

## Task 0 困难问题

### Background

别紧张，这不是说我们这个题目会很困难。我们在探讨的是密码学中“困难问题”的概念。

本题后面的 Task 中提到的算法，都和一个困难问题紧密相关呢。我们也可以简单回顾一下之前的知识。

### Task 0 任务

- RSA 算法基于什么困难问题？

## Task 1 DH 密钥交换

### Background

这是另一种风味！

当然，我们在一轮题目中，就已经接触过 DH 密钥交换了，不是吗？那时我们还完成了对 DH 密钥交换的中间人攻击呢。可是，DH 密钥交换是干什么的呢？如果你做完了题目而不能回答这个问题，证明你其实还是不了解 DH 密钥交换。

### Task 1 任务

讲解 DH 密钥交换：

- 作用；
- 基本思想；
- 具体流程；
- 安全性。

> 再提醒一下，别看任务写的比较简短，你提交的报告的质量可不要缩水哦。

## Task 2 Elgamal 算法

### Background

这是我们第一次见面，不过我们后面还会再见面的。

### Task 2 任务

讲解 Elgamal 算法：

- 公钥和私钥的生成；

- 加密、解密的过程及原理；

- Elgamal 算法的安全性。

## Task 3 磕 CP

### Background

~~啊啊啊啊啊啊啊，太好磕了，你们是一个一个基于同一个困难问题的香香软软的小~~ 拖出去，砍了。

CP 好磕，当然我们别磕破了。我们能磕破它吗？

### Task 3 任务

- DH 密钥交换和 Elgamal 算法有什么联系？
- 破解 Elgamal 需要解决的困难问题是什么？目前破解这个问题的算法有哪些？简述相关算法的原理。

- 既然有了这些算法，我们为什么还认为它是安全的？

# Basic 5

> 敲打出题人：@xing4c

## Task 0 赛博签名

### Background

你可能在很多地方见过赛博签名，比如各种社交平台或者视频网站的评论区。不过本题探讨的数字签名并非赛博签名。

~~当然，你也可以让批改题目的老东西在回复的时候给你一个赛博签名。~~

### Task 0 任务

- ~~找一个/几个赛博签名的截图给大伙看看~~
- 数字签名中，签名具体是指什么？有什么性质？

## Task 1 数字签名

### Background

还记得我们在一轮题目和前面的 Basic 系列题目中，提到数字签名时，是为了解决什么问题吗？

简单学习了相关概念之后，你对数字签名有什么理解？我们就来简单签几个名吧。

### Task 1 任务

1. 如何基于对称密码和可靠仲裁者进行签名？这样的方案有什么问题？

2. 基于非对称密码进行数字签名：（回答中请包含签名过程和验证过程）

   - 如何用 RSA 进行签名？

   - 如何用 Elgamal 进行签名？

## Task 2

### Background

> 数字签名的能力是有极限的，我从几种签名方式中学到一件事，就是越使用签名，越会发现签名的能力是有极限的，除非...

如果你认真完成了前面的题目，或者理解了前面题目说过的事情，那么这个 Task 对你来说应该很容易了。

### Task 2 任务

- 实际上，只有数字签名还是没办法完全防护中间人的攻击，为什么？
- 解决方案是什么？

# 神秘CDK.txt (baby)

我藏了一款游戏的 CDkey 在下面的神秘 `.txt` 文件里。请将 CDkey 作为你的 flag 内容提交。

PS：记得到 steam 上兑换哦，先到先得。

[神秘cdk.txt](https://github.com/Aununo/lr_studio_crypto/blob/main/ROUND%20I/%E7%A5%9E%E7%A7%98CDK.txt)

> flag 格式：lr_studio{ 你的 flag 内容 }

hint: 谁动了我的文件后缀？

# Man-in-the-Middle（baby）

Alice 和 Bob 通过 DH 协议交换密钥。可恶的攻击者 Risk 可以拦截并且篡改消息。请你模拟 Risk 进行中间人攻击，让 Alice 和 Bob 误认为双方已经共享密钥。（hint: netcat）

> nc 207.246.98.239 6666

```py
import socket

def handle_client(conn, addr):
    print(f"[新连接] {addr} 已连接。")
    try:
        p = 13
        g = 5
        a = 6
        b = 9
        m = 3

        A = pow(g, a, p)
        B = pow(g, b, p)
        M = pow(g, m, p)

        s_alice_risk = pow(M, a, p)
        s_bob_risk = pow(M, b, p)

        intro_msg = (
            "欢迎来到中间人攻击挑战！\n"
            "你需要连续正确回答三个问题才能获得 flag。\n"
            "--------------------------------------------------\n"
            f"公开参数有：素数p={p}，生成元g={g}；\n"
            f"Alice的私钥a={a}，Bob的私钥b={b}，中间人Risk的私钥m={m}；\n"
            "--------------------------------------------------\n\n"
        ).encode('utf-8')

        conn.sendall(intro_msg)

        questions = [
            ("问题 1: 在攻击中，Risk 拦截了 Alice 的公钥后，会发送什么给 Bob？", str(M)),
            ("问题 2: Alice 和 Risk 之间建立的共享密钥是什么？", str(s_alice_risk)),
            ("问题 3: Bob 和 Risk 之间建立的共享密钥是什么？", str(s_bob_risk))
        ]

        correct_answers = 0

        for i, (q, ans) in enumerate(questions):
            conn.sendall(f"{q}\n> ".encode('utf-8'))
            client_answer = conn.recv(1024).decode('utf-8').strip()

            if client_answer == ans:
                correct_answers += 1
                conn.sendall(f"回答正确！({correct_answers}/3)\n\n".encode('utf-8'))
            else:
                conn.sendall(f"回答错误。正确答案是 {ans}。连接已断开。\n".encode('utf-8'))
                break

        if correct_answers == 3:
            flag = "lr_studio{D1ff1e_he11man_1s_c00l!}\n"
            conn.sendall(f"恭喜你！你已成功理解中间人攻击！\nFlag: {flag}".encode('utf-8'))

    except Exception as e:
        print(f"[错误] {e}")
    finally:
        conn.close()
        print(f"[连接关闭] {addr}")

def main():
    host = '0.0.0.0'
    port = 6666

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((host, port))
    server_socket.listen(5)
    print(f"[*] 服务器正在监听 {host}:{port}")

    try:
        while True:
            conn, addr = server_socket.accept()
            handle_client(conn, addr)
    except KeyboardInterrupt:
        print("\n[*] 服务器正在关闭...")
    finally:
        server_socket.close()

if __name__ == '__main__':
    main()
```

# 三国演绎（easy）

> 本题提交形式不是 flag，请将你的解答以 markdown 文件撰写后以 PDF 文件形式提交。

诸葛亮北伐时，为蜀军设计了一个军令系统，将密令转为 12 位旗语信号（共 4096 种组合）。其绝密军令「出祁山」的信号为 010110011010。并且将在次日晚上发出信号。

然而，因为走漏风声，魏军知道蜀军采用 12 旗语作为信号。

魏国大将军曹真命人伪造此信号，如能在第二天晚上之前伪造出该信号即可扰乱蜀军部署。参军郭淮负责连续发射不同军令，每次随机生成旗语。

> 问题：郭淮需发射多少军令，才有 50% 概率复现「出祁山」？

司马懿得知后，决定采用类似的方式指挥作战，同样设计了12位旗语军令，且用多种信号来表示多条军令。诸葛亮得知后，不仅不担心，反而抚掌大笑，其中玄机就在于若两军令信号相同，不仅无法正常行军，反而会扰乱自家阵脚。

> 问题：魏军发出多少军令，有 75% 概率出现内部信号冲突？

# Old Key (easy)

*'One-time pad are perfectly information-theoretically secure, so I should be safe, right?' Bob thought.*

*We provided a Python source file, and two encrypted images.*

[picture.py](https://github.com/Aununo/lr_studio_crypto/blob/main/ROUND%20I/picture.py)

[twotimespad.zip](https://github.com/Aununo/lr_studio_crypto/blob/main/ROUND%20I/picture.zip)

> flag 格式：lr_studio{ 你的 flag 内容 }

# 好学的 Bob (easy)

在一个阳光明媚的午后，密码学爱好者 Bob 正兴奋地尝试实现 AES 加密算法。作为刚入门的新手，他对这种广泛应用于金融、通信领域的加密技术充满好奇。Bob 准备了一条 **16 字符**的秘密消息，打算用 AES 算法加密后分享给同为密码学爱好者的朋友。

**他选用了标准的 128 位原始密钥：**`00112233445566778899aabbccddeeff`，并按照自己理解的 AES 流程编写了加密代码。经过**密钥扩展**和**初始键添加**后，他进行了**一个轮次**的加密，一位朋友说Bob的实现过程有很多问题。

**经过一番排查，Bob 沮丧地发现自己在实现过程中犯了两个致命错误：**

1. 完全漏掉了轮次中的 **SubBytes** 和 **MixColumns** 这两个关键步骤
2. 在**密钥扩展**阶段偷工减料，直接将**原始密钥**转换为 4×4 矩阵作为轮密钥使用

更糟糕的是，他只保留了**最终**加密得到的矩阵结果，**原始消息**已经被他不小心删除了。

**已知 Bob 加密后得到的矩阵为：**

```
[
    [99, 114, 121, 112],
    [126, 72, 120, 71],
    [67, 86, 76, 79],
    [78, 99, 90, 105]
]
```

请你还原出原来 16 字符的秘密消息，提交出你的解密过程和最终结果（Hint：AES加密的逆向操作）

> flag 格式：lr_studio{ 16字符的秘密消息 }

# Schnorr (mid)

## **🤨Challenge 1（10%）**

在管理用户账户时，能否直接将用户的账号密码明文记录在服务器中，为什么？如果不能，你会怎么做？

- Hint1：Oh, NO! I forgot my password. How to find it back?
- Hint2：One-Way Function.

## **🤔Challenge 2（45%）**

Aununo想直接舍弃这套密码系统，让每个用户自己生成一份公私钥对。通过一系列操作，实现身份识别。请你画出Schnorr Identification Schemes的流程图，编写程序实现一个简易的身份识别协议，并分析协议的安全性（健全性、完备性与零知识性）。

## **😐Challenge 3（45%）**

你听过后，觉得Aununo的方案确实不错，但是存在一个严重的问题：只有当双方同时在线时才能进行身份识别（为什么？），严重影响了使用的便利性，于是你给出了改造后的方案......

- Attention：存在即合理。请在学习过程中思考协议每一步背后的原因。

## **😵‍💫Optional Boss（50%）**

进行以下对Schnorr协议的改造：

1. 可在验证者不诚实的情境下证明安全性；
2. 可在证明者不诚实的情境下证明安全性。

给出上述改造后的流程与安全证明。Tips：commit

# 秘密共享 I (mid)

## 任务描述

1. **了解拉格朗日插值法，并学习 Shamir 秘密共享，详细介绍 Shamir 秘密共享方案的步骤和流程。(30%)**

2. **思考一下在简的卧底任务中，为什么需要用到秘密共享方案？它相较于传统的加密方案的好处是什么呢？(10%)**

3. **基于 Shamir 秘密共享，思考下面问题：(40%)**

    假设简获取了一段加密代码，这段代码是用于打开最后一道关卡的关键。为了确保这个代码不会被山狮的成员截获，简决定使用 \( (n, t) = (3, 2) \) 的阈值方案来保护这段密码：
    - 简将密码的前 6 位共享给了她的一位同事，他知道第1,2,3,4,5,6位。
    - 第二位同事掌握了密码的前 3 位和最后 3 位，他知道第1,2,3,7,8,9位。
    - 第三位同事则知道密码的后 6 位，他知道第4,5,6,7,8,9位。

    通过这种方式，他们可以实现阈值方案，但也存在一定的问题：
    - 请分析这种构造方式相较于 Shamir 秘密共享方案有哪些潜在的问题？（20%）
    - 如果简有多个秘密需要通过 \( (n, t) \) 的阈值方案进行共享，除了 Shamir 方案之外，你还能想到其他方法来进行秘密共享吗？（20%）

4. **使用编程语言，当输入 n 个点时，输出过这 n 个点的 n-1 阶曲线的解析式。(20%)**

# 灵梦代码的密码 (mid)

Bob，是一位年轻的黑客，父亲曾是著名的计算机科学家，但在多年之前神秘失踪。他一直相信父亲并没有死，而是隐藏在某个未知的地方，掌握着一把通向“灵梦代码”的钥匙。

有一天，Bob在父亲遗留的笔记中找到了一段奇怪的文字，它包含了一些参数，看似简单，但却能引发他对“灵梦代码”的破解。通过分析，发现父亲曾使用一种线性同余生成器（LCG）加密信息，而破解这个生成器的flag是他解开父亲失踪谜团的唯一途径。

```py
import random
from Crypto.Util.number import bytes_to_long, long_to_bytes

flag = b"crypto{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}"

# 线性同余生成器参数
   a = 0x35  # 53
   c = 0x23  # 35
   m = 1009  # 质数模

# 生成随机种子
seed = random.getrandbits(10)

def lcg_next(state):
    """生成下一个LCG状态"""
    return (a * state + c) % m

def encrypt(data, initial_state):
    """使用LCG生成的密钥流进行异或加密"""
    state = initial_state
    encrypted = []
    for b in data:
        # 从状态中提取8位作为密钥
        key = state & 0xFF
        encrypted.append(b ^ key)
        # 更新状态
        state = lcg_next(state)
    return bytes(encrypted)

# 加密flag
encrypted_flag = encrypt(flag, seed)

# 泄露部分信息：前8个字节的明文和密文
known_plaintext = flag[:8]
known_ciphertext = encrypted_flag[:8]

# 输出已知信息
print(f"已知明文前8字节: {known_plaintext.hex()}")
print(f"对应密文前8字节: {known_ciphertext.hex()}")
print(f"完整密文: {encrypted_flag.hex()}")

"""
输出:
已知明文前8字节: 63727970746f7b6c
对应密文前8字节: 5ec6fa1e724b76ca
完整密文: 5ec6fa1e724b76ca9a6f94a3f62eb7e403331ac49cc7b5ab7e172f84
"""
```

hint(枚举验证种子)
> flag 格式：lr_studio{ crypto{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} }

# 阿里巴巴和奇怪的洞穴 (mid)

> 本题提交形式不是 flag，请将你的解答以 markdown 文件撰写后以 PDF 文件形式提交。

在遥远的东方，有一个神秘的洞穴，传说中藏有无尽的宝藏。只有掌握开门咒语的人，才能开启这座洞穴的大门。
有一天，阿里巴巴无意间发现了洞穴的咒语。四十大盗听说了这件事，于是他们抓住了阿里巴巴，强迫他说出咒语。
阿里巴巴知道，如果他说出咒语，就会因为没有利用价值而被杀死，而如果阿里巴巴坚持不说，强盗不会相信他真的掌握咒语，也会杀死他。聪明的阿里巴巴想到了利用**零知识证明**来让强盗们暂时不会杀了自己。

1. 请你说明什么是零知识证明并解释它的三个性质。
2. 假设山洞的构造如下图所示，阿里巴巴所知道的咒语能够打开 C 与 D 之间的门，请设计一个零知识证明协议帮助阿里巴巴化险为夷。经过多次操作后，强盗便只能相信阿里巴巴确实知道洞穴的咒语，为什么？阿里巴巴有可能不知道咒语却蒙混过关吗？

<div align=center><img src="https://pic.imgdb.cn/item/650025f0661c6c8e54e1934e.jpg" width="  "></div>

> [How to Explain Zero-Knowledge Protocols to Your Children](https://pages.cs.wisc.edu/~mkowalcz/628.pdf)

时间来到了现代，你重新发现了阿里巴巴洞穴的咒语并想跟你的一个远方的朋友炫耀，当然你也想让 ta 确信你知道洞穴的咒语而不让 ta 知道咒语具体是什么。然而由于朋友不在你身边，上面的协议无法使用，并且你也想使用一些更高级的零知识证明协议。你听说有一个叫 Sigma 协议的抽象协议。

3. 请你简要讲解一下 Sigma 协议的流程。
4. 你决定使用一个 Sigma 协议的具体实现————Schnorr 协议向你的朋友证明你知道咒语。
   你们选定了模 $p=65579$ 的乘法群，生成元 $g=5$，群的阶 $q=32789$。

   a. 如果秘密咒语 $x=1688$，那么你们之间共享的公共值 $h=g^x$ 为多少？
   b. 如果你选定了随机数 $r=31416$，在协议的第一步你应该向你的朋友发送的数 $a$ 等于多少？
   c. 你的朋友将 $h$ 和 $a$ 作为字符串连接在一起，然后将该字符串输入下面的代码得到其哈希值，取哈希值前 4 位转换成十进制后发送给你，记 ta 发送给你的数为 $e$。那么接下来你给 ta 发送的数 $z$ 为多少？
```python
import hashlib
from Crypto.Util.number import *

str="..."  # h和a连接后所得的字符串
sha=hashlib.sha256()
bytes=str.encode('utf-8')
sha.update(bytes)
hex=sha.hexdigest()
print(hex)
```
   d. 最后你的朋友要如何验证？

**附加题**：你们觉得你们选的乘法群的模和阶都太小了，容易被暴力破解。你能找到一个以 5 为生成元，模为二进制下 512 位素数，阶也尽可能大的乘法群吗？
> PS:
> 1. 二进制 512 位远远超过了一般编程语言内置数据类型的范围，也许你需要一些第三方库？GMP 库？
> 2. 要判断一个如此大的数是否为素数是非常困难的，但是判断一个数是否有很大概率为素数却简单得多，并且一些第三方库里面也有相关函数。一般来说，如果一个数有 $\dfrac{1}{2^{32}}$ 的概率为合数，就已经足够了。
> 3. 在 i9-13900HX 的 CPU 和 16GB 的内存大小下，程序可以在 20 秒内找到一个符合题目条件的模数，其为合数的概率小于 $\dfrac{1}{2^{200000}}$。所以如果程序长时间没有输出结果，请首先检查程序的算法是否合理而非怀疑电脑性能不够。

# SecureLCG (mid)

嘿！我黑进后台拿到了下面的代码 ... 也许你需要 pwntools.

```python
class SecureLCG:
    def __init__(self, seed, a, c, m):
        self.state = seed
        self.a = a
        self.c = c
        self.m = 1000000007
    def __next__(self):
        self.state = (self.a * self.state + self.c) % self.m
        return self.state
```
> nc 207.246.98.239 9999

```py
import socketserver
import threading

M = 1000000007
A = 65537
C = 12345
FLAG = "lr_studio{LCg_1s_n0t_aS_SecUr3_@s_u_thought}"

class GameHandler(socketserver.BaseRequestHandler):
    def handle(self):
        client_address = self.client_address[0]
        log_prefix = f"[{client_address}]"
        print(f"{log_prefix} New connection.")

        self.rfile = self.request.makefile('rb')
        self.wfile = self.request.makefile('wb')

        try:
            self.send_line("We've already known the first 3 numbers: 273996043, 878556744, 972940834")
            self.send_line("You must predict the next 100 numbers in a row to get the flag.")
            self.send_line("="*60)

            current_state = 972940834 # X_3
            guesses_to_win = 100

            for i in range(guesses_to_win):
                correct_answer = (A * current_state + C) % M

                prompt = f"[Round {i+1}/{guesses_to_win}] Guess the next number: "
                self.send(prompt)

                guess_str = self.rfile.readline().strip().decode('utf-8')
                if not guess_str:
                    print(f"{log_prefix} Client disconnected.")
                    return

                guess_num = int(guess_str)

                if guess_num == correct_answer:
                    self.send_line("Correct!")
                    current_state = correct_answer
                else:
                    self.send_line(f"Wrong answer. Connection closed.")
                    print(f"{log_prefix} Guessed wrong. Closing connection.")
                    return

            self.send_line("\n" + "="*60)
            self.send_line("Congratulations! You are a true LCG cracker!")
            self.send_line(f"Here is your flag: {FLAG}")
            self.send_line("="*60)
            print(f"{log_prefix} Challenge solved! Flag sent.")

        except (ValueError, TypeError):
            print(f"{log_prefix} Invalid input. Closing connection.")
        except ConnectionResetError:
            print(f"{log_prefix} Connection reset by peer.")
        finally:
            self.rfile.close()
            self.wfile.close()
            print(f"{log_prefix} Connection closed.")

    def send(self, message):
        self.wfile.write(message.encode('utf-8'))
        self.wfile.flush()

    def send_line(self, message):
        self.send(message + '\n')

class ThreadedTCPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    pass

if __name__ == "__main__":
    HOST, PORT = "0.0.0.0", 9999
    socketserver.TCPServer.allow_reuse_address = True
    server = ThreadedTCPServer((HOST, PORT), GameHandler)

    print(f"[*] Server listening on {HOST}:{PORT}")
    print("[*] Ready to accept multiple connections...")
    server.serve_forever()
```

# 数论糕手 (hard)

Alice有一句话想送给刚学习密码学的Bob,但考虑到Bob初学crypto便采用了一种简单的加密方式，你能帮Bob还原出这句话的内容吗？

[1.py](https://github.com/Aununo/lr_studio_crypto/blob/main/ROUND%20II/1.py)

Bob收到Alice送给他的话后非常感动，于是自己设计了一个加密方案，你能够破解Bob的加密方案吗？（hint: Jacobi符号）

[2.py](https://github.com/Aununo/lr_studio_crypto/blob/main/ROUND%20II/2.py)

Bob对crypto的兴趣越来越深了，为此他设计了一个协议：允许证明者（Prover）向验证者（Verifier）证明其知道一个秘密 s（满足$v=s^2(mod n)$） ，其中$n=pq$，p和q都是大素数），而不泄露 s 本身。协议一轮的基本步骤如下：

1. 证明者选择随机数 r，计算 $x=r^2(mod~n)$ ,并发送 x 给验证者。
2. 验证者随机选择挑战比特 b∈{0,1}，并发送 b 给证明者。
3. 证明者根据 b 计算响应 y：
   如果 b=0，则$y=r$。
   如果 b=1，则$y=r⋅s（mod~n）$。
4. 验证者检查：
   如果b=0，则$y^2\equiv{x}(mod~n)$ 。
   如果b=1，则 $y^2\equiv{x*v}(mod~n)$ 。
   如果验证通过，则接受本轮；否则拒绝。

Q1：一开始，Bob在选取n的时候打算用一个大素数，但是却被告知这会产生安全问题，试分析其原因

Q2：如果证明者有若干个秘密，请设计一种协议能够使证明者能够向验证者证明自己知道这些秘密，同时又不泄露这些秘密的内容。
（hint： fait - shamir）

# 猫和老鼠 (hard)

方案一：

Jerry 和 Tuffy 最近发现了一种基于复合剩余类问题的非对称加密方式，这使他们将消息传给其他老鼠时不用担心被 Tom 窃听。

为了让其他的老鼠更好地理解并接受这套加密方案，Jerry 决定：

Q1：画出paillier同态加密的流程图，并验证其正确性；

Q2：验证加法同态的正确性。

现在，Jerry 将一条信息分为两个部分先后发送给了 Tuffy，请你帮助可爱的小 Tuffy 还原这条信息的原始内容吧！

[3.py](https://github.com/Aununo/lr_studio_crypto/blob/main/ROUND%20II/3.py)

方案二：

有一天，来自那不勒斯的老鼠来到了 Tom 和 Jerry 的家，在听说了 Jerry 和 Tuffy 发现的加密方案非常感兴趣，了解了其背后的原理后，又提出了新的加密方案，其加密方式为：

- 奶酪位置信息：m < n²
- 将 m 分解为 m₁, m₂，使得 m = m₁ + n m₂
- 密文 c = g^m₁ m₂ⁿ mod n²

Jerry想了很久也没有想出解密方法，请你把解密方式告诉Jerry吧！

为了推广这一类加密方案，Jerry发现证明其安全性也是很有必要

Q1：证明方案1是语义安全的

Q2：那波利鼠给出的实际上是一个单向陷门函数，请证明它是单向的吧！

（hint: 以 g 为基的 n 次剩余类问题）

# 时序攻击 (hard)

计算机密码的存在已有很长历史。事实上，60年前的CTSS（兼容分时系统）就是最早配备密码功能的计算机之一。其实现方式非常简单：CTSS将密码以明文形式存储在磁盘文件中。用户登录时输入密码，系统会将输入内容与磁盘存储的密码进行比对。若比对失败则拒绝访问，若成功则允许访问。麻省理工学院的研究人员很快发现了该密码系统的若干安全漏洞，我们将探讨其中一种——时序攻击。

这种攻击方式通过计算耗时来推断程序执行路径。CTSS使用的密码检查算法是简单的字符串匹配，其原理类似如下实现：

```c
bool CheckPassword(string pwd1, string pwd2) {
    if (pwd1.Length != pwd2.Length) {
        return false;
    }
    for (int i = 0; i < pwd1.Length; i++) {
        if (pwd1[i] != pwd2[i]) {
            return false;
        }
    }
    return true;
}
```

针对本问题，我们将采用（高度）简化的计时模型及上述算法。该计时模型具体规定如下：

* 分支语句（如if或for）执行耗时1毫秒
* 内存地址的赋值或更新操作耗时1毫秒
* 两个内存地址间的比较操作耗时3毫秒
* 返回语句耗时1毫秒

密码由1到20个英文字母（大小写均可）及数字组成。

**交互说明**
本题为交互式题目。您的程序将与一个交互器进行通信——该交互器会读取您程序的标准输出，并向您程序的标准输入写入数据。此交互过程需遵循特定协议：

* 您的程序首先发送一个密码字符串，该密码由1至20个英文字母（大小写均可）及数字组成。
* 根据密码正确与否，交互器将作出如下响应：
  * 若密码正确：返回"ACCESS GRANTED"。您的程序应在收到此信息后正常退出。
  * 若密码错误：返回"ACCESS DENIED (t ms)"，其中t表示验证密码所耗费的毫秒数。收到该响应后，您的程序可继续进行下一次猜测。
* 请确保在每次输出后刷新缓冲区。您的程序最多允许进行 $2500$ 次猜测。需要注意的是每次输出后你应当使用 $fflush(stdout)$ 刷新缓冲区。

**样例（仅代表一个可能的交互过程）**

```c
Your program:A
Interactor:ACCESS DENIED (5 ms)
Your program:HunFhun
Interactor:ACCESS DENIED (41 ms)
Your program:Hunter1
Interactor:ACCESS DENIED (68 ms)
Your program:Hunter2
Interactor:ACCESS GRANTED
```

# 鹊桥仙 · 天河之东 (hard)

“天河之东，有织女，天帝之子也。年年织杼役，织成云锦天衣。天帝怜其独处，许嫁河西牵牛郎。嫁后遂废织纴。天帝怒，责令归河东。唯每年七月七日夜，渡河一会。” 牛郎织女的爱情受到天帝的阻碍，他们只有在每年七夕才能相见，所以他们常常进行远程的信息交换，并且用上了密码学中的加密算法和数字签名，防止他们的情话被某些奇怪的人窃听和篡改。

而你对这样的信息传输方式感到好奇和有趣，于是也想学习相关密码学知识。你发现现代信息安全要求保密性，完整性，认证性和不可否认性。其往往依赖于密码学进行实现。你觉得你该学习以下几方面 (10%)：

- 了解并梳理常见密码学中的困难问题，并说说RSA和Elgamal分别是基于什么困难问题的。
- 了解双线性对的性质。

下面是牛郎和织女使用过的几个签名机制（均在 $Z_p^*$下），请说说如何针对这些签名机制进行
验证：

1. (10%)

> 公钥是 $pk = (e,n)$ 私钥是 $sk = (d,n) ∈Z_p$，
>
>其中 $ed \equiv 1\ mod\ \varphi(n),gcd(e,\varphi(n))=1$
>
>
> **假如消息m的签名是**
>
> $σ_m=m^d\ mod\ n$
>
> ***Question：* 当你知道($pk$, $m$, $\sigma_m$)时，如何进行验证**?
>

1. (10%)

> 公钥是 $pk = (g,g^\alpha)$ 私钥是 $sk = α ∈Z_p$.
>
>
> **假如消息m的签名是**
>
> $σ_m=(\alpha \cdot m +r,g^r)$
>
> ***Question：* 当你知道$(pk,m,\sigma_m)$时，如何进行验证**?
>

1. (15%)

> 公钥是 $pk = (g,g^\alpha,g^{\beta} )$ 私钥是 $sk = (\alpha,\beta ) ∈Z_p.$
>
>
> **假如消息m的签名是**
>
> $σ_m=g^{\frac{\alpha-m}{\beta-m}}$
>
> ***Question：*当你知道$(pk,m,\sigma_m)$时，如何进行验证**?
>

1. (15%)

> 公钥是 $pk = (g,g^\alpha,g^\beta)$ 私钥是 $sk = (\alpha,\beta) ∈Z_p.$
>
>
> **假如消息m的签名是**
>
> $σ_m=(g^{\alpha \beta\cdot m +\alpha \beta \cdot r},g^r)$
>
> ***Question：* 当你知道$(pk,m,\sigma_m)$时，如何进行验证**?
>

天帝偶然发现了牛郎织女的传话，于是他学习了密码学中的数字签名，想要阻止牛郎织女的进一步发展。在一次传输过程中，天帝截获了他们的一条消息和签名，他发现这个签名机制并不安全，他可以篡改消息去破坏两人的关系。

天帝的发现：

> 公钥是 $pk = (g,g^\alpha)$ 私钥是 $sk = α ∈Z_p.$
>
>
> **消息m的签名是**
>
> $σ_m=g^{\alpha + m}$
>
> 知道$(pk,m,\sigma_m)$时，天帝发现他可以构造出新签名$σ_m^*=g^{\alpha}\cdot (g)^{m^*}=g^{\alpha+m^*}$，再将$(m^*,σ_m^*)$发给另外一方。而这条伪造的消息按照正常的验证流程是完全可以以假乱真通过验证的，也就是说天帝成功破解了该签名。
>

你对天帝这种行为十分生气，但这些**可以把伪造的消息的和签名发送给接收方，接收方仍按照原先验证的方式进行验证依然可以通过验证**的签名机制确实不安全，于是你抢先一步发现了其它几个不安全的签名机制(均在$Z_p^*$下)。你针对这些机制进行了破解，对新消息生成新的签名，并发给牛郎提醒他。

1. (10%)

> 公钥是  $pk = (g,g^\alpha,g^\beta)$ 私钥是$sk = (\alpha,\beta) ∈Z_p.$
>
>
> **假如消息m的签名是**
>
> $σ_m=g^{\alpha m+\beta}$
>
> ***Question：*当你知道$(pk,m,\sigma_m)$时，如何伪造一条任意其它信息的签名**？
>

1. **(15%)**

> 公钥是  $pk = (g,g^\alpha,g^\beta)$ 私钥是$sk = (\alpha,\beta) ∈Z_p.$
>
>
> **假如消息m的签名是**
>
> $σ_m=(g^{\alpha \beta+m \cdot \beta r},g^r)$
>
> ***Question：* 当你知道$(pk,m,\sigma_m)$时，如何伪造一条任意其它信息的签名**？
>
> **Additional question：如何检验这个签名？**
>

1. (15%)

> 公钥是  $pk = (g,g^\alpha,g^\beta)$ 私钥是$sk = (\alpha,\beta) ∈Z_p.$
>
>
> **假如消息m的签名是**
>
> $σ_m=(g^{\alpha^2 \beta+\alpha \beta \cdot mr},g^r)$
>
> ***Question：*当你知道$(pk,m,\sigma_m)$时，如何伪造一条任意其它信息的签名**？
>
> **Additional question：如何检验这个签名？**
>

# 東方密碼學 ~ Non-interactive Zero-knowledge (boss)

> 如标题所示，我会给在本题中获得最高分数的小登送一个CDKey，请这位同学在二轮笔试结束后联系我（如果真有的话）。
> 本题原来是去年的密码学二轮压轴题，因为难度不合理~~和我编的故事太差劲了，哪有灵梦解决异变还整天呆在神社的（bushi~~等原因本来决定今年重制，结果发现还是不会编故事于是就算了。然而为了吸引大家来做密码学，引导感兴趣的同学学习zkSNARK，以及发福利~~还有传教~~，我把这题修改了亿下发了出来。
>
> 本题与去年相比，增加了Stage 6，在其它Stage增加了几道题，增加了一些提示，还换了张配图。
>
> PS：
> 1. 本题**完全不涉及代码**，写代码题写累了可以来这里放松一下（
> 2. 本题的**难度在于读懂题意而非计算**，请不要被数学符号吓到了，它们背后的运算可能最多只有初中的解方程。
> 3. 本题的**Stage 6难度远远超过前面的题目**，可以算是附加题的附加题了。请不要因为Stage 6而对前面的题目难度产生误解，认为前面的题目也非常难；也请量力而行，不要在做完前5个Stage后死磕Stage 6。
> 4. 求求你们了来做密码学吧QAQ
>
> 出题人`@Null314159`，QQ：1807640865

$\kern{1.67 em}$幻想乡是一个在日本的偏远深山之中的被结界包围的地方，妖怪引起异变而解决异变的专家去解决异变是幻想乡的日常。
$\kern{1.67 em}$一天，幻想乡的巫女博丽灵梦收到了一份《文文。新闻》报纸。她从报纸上得知，交易之神天弓千亦准备在幻想乡内创建区块链以进行交易。为了防止产生异变，灵梦决定调查一下区块链是什么。境界的妖怪八云紫突然出现在神社，她建议灵梦先学习 zk-SNARK 的知识，并拿了点吃的，然后就不见了。

## 第一部分：预备知识

### Stage 1:

精通密码学的你决定给灵梦讲解 zk-SNARK。请你给灵梦解释以下问题：

1. **Schwartz-Zippel 引理**是什么？
2. 在"zk-SNARK"这个缩写中，<strong>"zk"</strong>,<strong>"S"</strong>,<strong>"N"</strong>和<strong>"ARK"</strong>分别是什么意思？其中的<strong>"AR"</strong>与<strong>"Proofs"</strong>有什么区别？

> 八云紫のHint：破解可靠性所需的计算资源

3. 在之前的题目中你学习了 Schnorr 协议，很明显其与 zk-SNARK 协议的一个区别是 Schnorr 协议是交互式的，然而其实 Schnorr 协议也能被改造为非交互式的（请自行搜索：Fiat-Shamir 变换）。那么为什么还要有 zk-SNARK？非交互式 Schnorr 协议不就够了吗，它们还在哪个方面不同吗？

> 八云紫のHint：秘密与公开值之间的关系

## 第二部分：Groth16

### Stage 2:

$\kern{1.67 em}$灵梦的好朋友雾雨魔理沙从红魔馆的地下图书馆“借”来了一本科普 zk-SNARK 的书。灵梦看到书里讲到了一个叫 **Groth16** 的协议，协议的大致流程是：首先把要证明的计算关系转换成数字电路并用 R1CS 描述，然后再转换为 QAP 多项式并构造多项式整除问题，最后把多项式系数放到椭圆曲线离散对数点上构造多项式承诺，生成证明。直觉敏锐的灵梦意识到如果要学习多项式承诺那难度可能直奔凌睿密码学大二内推了，不如先学习前面的知识。但是这本书里并没有对流程的进一步解释，所以还是要你给灵梦讲解 Groth16。

1. 你可以向灵梦解释 **R1CS** 是什么意思吗？
2. 你觉得如果给她举个例子会更好理解，请你**把位异或运算关系 **$a ⊕ b = c$** 转换成 R1CS** 以方便她理解吧（其中 $a,b,c$ 都是布尔值）。

> 八云紫のHint：“$a,b,c$ 都是布尔值”也属于约束

3. **QAP多项式**和**多项式整除问题**又是什么？

<img src="https://pic.imgdb.cn/item/66fd655df21886ccc043978b.png">
<center><a href="https://x.com/thkani/status/774480464744546304">原图链接</a></center>

### Stage 3:

$\kern{1.67 em}$图书馆的管理者帕秋莉·诺蕾姬找来了神社，要拿回这本书。魔理沙却说：“反正跟你们的人生相比我的一生压倒性地短，等我死后再全部收回去不就好了吗DA☆ZE”并拒绝归还。这时爱玩的红魔馆二小姐芙兰朵露·斯卡蕾特也来了，正好她在外界有一个化身是凌睿工作室22级密码学方向的成员，于是她提议，只要你能陪她玩，解出一道 Groth16 的题目，魔理沙就可以留着这本书，否则她就会把这本书的“目”捏爆。请你帮魔理沙解出这道题以留住这本书吧。<br/>

1. 芙兰朵露的题目如下：
   设某计算关系转换成的数字电路有4个电路门，第$i$个电路门等价于等式：

$$
(\overrightarrow a_i\cdot \overrightarrow v)\times(\overrightarrow b_i\cdot\overrightarrow v)-\overrightarrow c_i\cdot\overrightarrow v=0
$$

已知：

$$
A=\begin{pmatrix}
\overrightarrow a_1 \\
\overrightarrow a_2 \\
\overrightarrow a_3 \\
\overrightarrow a_4
\end{pmatrix}=\begin{pmatrix}
0&1&0&0&0&0 \\
0&0&0&1&0&0 \\
0&-2&0&0&1&0 \\
-1&0&0&0&0&1
\end{pmatrix},
B=\begin{pmatrix}
\overrightarrow b_1 \\
\overrightarrow b_2 \\
\overrightarrow b_3 \\
\overrightarrow b_4
\end{pmatrix}=\begin{pmatrix}
0&1&0&0&0&0 \\
0&1&0&0&0&0 \\
1&0&0&0&0&0 \\
1&0&0&0&0&0
\end{pmatrix},
C=\begin{pmatrix}
\overrightarrow c_1 \\
\overrightarrow c_2 \\
\overrightarrow c_3 \\
\overrightarrow c_4
\end{pmatrix}=\begin{pmatrix}
0&0&0&1&0&0 \\
0&0&0&0&1&0 \\
0&0&0&0&0&1 \\
0&0&1&0&0&0
\end{pmatrix}
$$

解向量 $\overrightarrow v=(\text{\textasciitilde}one,x,\text{\textasciitilde}out,s_1,s_2,s_3)$，其中 $\text{\textasciitilde}one$ 为表示1的冗余变量，$x$ 为输入变量，$\text{\textasciitilde}out$ 为表示输出的冗余变量，$s_1,s_2,s_3$ 为中间变量。
若 $\text{\textasciitilde}out=495$，请**写出这个计算关系的 R1CS**，然后**画出这个电路**，并说出**这个电路等价于什么计算关系**。
（附加问题不计分：满足该计算关系的实数 $x$ 等于多少？~~如果得到的计算关系正确那应该一眼就能看出来吧~~）

<img src="https://pic.imgdb.cn/item/66fd6c0af21886ccc04aba3c.jpg">
<center><a href="https://x.com/wagocolo/status/1545736860093526017">原图链接</a></center>

$\kern{1.67 em}$成功解出题目后，灵梦说着“好孩子的话现在就乖乖地回家睡觉”把芙兰朵露轰回了红魔馆。然而帕秋莉却还要求魔理沙把书还回去，请你再回答帕秋莉的问题，用你的智慧留下这本书吧。

2. 帕秋莉的问题：上述的芙兰朵露的电路有四个电路门，但是其实可以优化成两个电路门，请<strong>写出优化后的 R1CS</strong>。

## 第三部分：Plonk

$\kern{1.67 em}$终于把帕秋莉也轰走后，河童的首领河城荷取正好也来到了神社谈生意。她看见灵梦正在看 Groth16 ，澄清说千亦的区块链其实是用的另一个叫 **Plonk** 的协议。因为如果用 Groth16，每次算法更新都要由河童生产硬件来产生 CRS，而算出 CRS 后就要砸坏硬件。使用 Plonk 协议则算法更新后不用更新硬件计算出的那部分 CRS，因此避免了许多浪费。
$\kern{1.67 em}$灵梦跳到讲 Plonk 协议的那部分，发现 Plonk 协议同样遵循先把计算关系转化为电路，再用多项式描述，最后构造多项式承诺生成证明的流程。灵梦决定同样先把 Plonk 电路搞懂。书里说：在 Plonk 中，计算关系转化成的数字电路可以拆解成两种约束：门约束（Gate Constraint）和复制约束（Copy Constraints，也译作置换约束、拷贝约束、线约束等）。书里同样没有进一步的解释。

### Stage 4:

1. 请给灵梦解释：对于某个特定的 Plonk 数字电路，**门约束**保证了什么内容？
2. 冰之妖精琪露诺也来到了神社。她自称新学会了一些计算关系，但是当灵梦问她学会了什么的时候，她却不告诉灵梦。她说，花之妖怪风见幽香帮她把计算关系转换成了 Plonk 电路门并算出了门约束方程，要想知道她学会了什么就要还原出电路门。<br/>
   已知电路的**门约束方程**为:

   $$
   Q_L(x)\cdot a(x)+Q_R(x)\cdot b(x)+Q_O(x)\cdot c(x)+Q_M(x)\cdot a(x)b(x)+Q_C(x)=Z(x)\cdot H(x)\quad (x=0,1,2)
   $$

   其中：

   $$
   \begin{cases}Q_L(x)=x^2-2x+1\\[5pt]
   Q_R(x)=\dfrac{1}{2}x^2-\dfrac{3}{2}x+1\\[5pt]
   Q_O(x)=\dfrac{1}{2}x^2-\dfrac{1}{2}x-1\\[5pt]
   Q_M(x)=-x^2+2x\\[5pt]
   Q_C(x)=-\dfrac{9}{2}x^2+\dfrac{9}{2}x\end{cases}\quad
   \begin{cases}a(x)=a_x\\
   b(x)=b_x\\
   c(x)=c_x\\
   Z(x)=x(x-1)(x-2)\end{cases}
   $$

   $H(x)$ 为关于 $x$ 的多项式。
   根据以上信息，你能帮灵梦**还原出电路门**吗？

### Stage 5:

1. Plonk 电路除了门约束之外还包括复制约束。请给灵梦解释：**复制约束**又保证了什么内容？
2. 山上的守矢神社的巫女东风谷早苗也来博丽神社玩了。灵梦知道她在来到幻想乡之前是理科生，于是趁此机会向早苗问复制约束的大致原理。早苗说复制约束使用了一个叫“坐标对累加器”的东西。<br/>
   请你学习**坐标对累加器**，并解答早苗提出的思考题：
   “设 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$ 是n个数对，对于 $\forall i,j\in\{1,2,\ldots,n\}$ 且 $i≠j$ 均有 $x_i≠x_j$。
   设

   $$
   \begin{alignedat}{2}
   &P(0)=P'(0)=1&&\\
   &P(i)=P(i-1)\cdot(u+x_i+v\cdot y_i)&\qquad&i\in\{1,2,\ldots,n\}\\
   &P'(p)=P'(p-1)\cdot(u+x_q+v\cdot y_p)&&\\
   &P'(q)=P'(q-1)\cdot(u+x_p+v\cdot y_q)&&\\
   &P'(i)=P'(i-1)\cdot(u+x_i+v\cdot y_i)&&i\in(\{1,2,\ldots,n\}-\{p,q\})
   \end{alignedat}
   $$

   其中 $n,p,q$ 为正整数，并且$1\leqslant p<q\leqslant n$，而 $u,v$ 为随机常数。请问：

   1. 若 $y_p=y_q$，是否有 $P(n)=P'(n)$？
   2. 反之，若 $P(n)=P'(n)$，是否有 $y_p=y_q$？为什么可以用坐标对累加器保证复制约束的正确性？
   3. 对于有三端口的电路门（比如琪露诺给出的），要为每组端口都计算坐标对累加器，比如 $P_a(n),P_b(n),P_c(n)$ 等等，那么它们的复制约束应该是什么样的？”

> 八云紫のHint：
> 第二问：Schwartz-Zippel 引理
> 第三问：注意可能存在跨组的复制约束，如 $a_p=b_q$ 等等

<img src="https://pic1.imgdb.cn/item/68d34473c5157e1a882c1415.jpg">
<center>画师：宮瀬まひろ 望月椎那  <del>链接自己搜</del></center>

## 第四部分：Groth16 的多项式承诺

### Stage 6:

$\kern{1.67 em}$这部分是今年新加的所以没有编故事，反正相对于故事来说，更重要的是题目内容，不是吗（
$\kern{1.67 em}$总之就是，你学了前面的知识所以觉得你很牛逼了，所以想进一步学习 Groth16 的多项式承诺。
$\kern{1.67 em}$以 Stage 3 中芙兰朵露的电路为例，首先你注意到，这些电路门的等式可以使用矩阵乘法和向量内积来表达：

$$
(\overrightarrow v\times A)\cdot(\overrightarrow v\times B)=\overrightarrow v\times C
$$

$\kern{1.67 em}$所以我们可以抛弃所有的 $\overrightarrow a_i,\overrightarrow b_i,\overrightarrow c_i$ 而去处理 $\overrightarrow v$ 和矩阵 $A,B,C$。为了使其转化为 QAP 多项式，我们再将矩阵中的元素作为多项式的值，把矩阵转换为多项式系数表达：

$$
A(x)=[a_0(x),a_1(x),a_2(x),a_3(x),a_4(x),a_5(x)]\\
B(x)=[b_0(x),b_1(x),b_2(x),b_3(x),b_4(x),b_5(x)]\\
C(x)=[c_0(x),c_1(x),c_2(x),c_3(x),c_4(x),c_5(x)]
$$

其中 $x=0,1,2,3$
问题：

1. 我们可以**用什么算法计算多项式系数**？并使用其中一种算法**计算这三个矩阵的多项式系数表达式**。
2. 从这些多项式得到的 **QAP 多项式和多项式整除问题**是什么样的？

$\kern{1.67 em}$现在要证明上述多项式整除问题的整除关系，必须要公开秘密向量 $\overrightarrow v$ 才行，这是与零知识相悖的。所以我们需要另一个密码学工具：双线性配对（Bilinear Pairing，又译作双线性映射等）。

3. 请你解释**双线性配对**的概念。由于**哪三个性质**，一个普通的映射会成为密码学里面常用的双线性配对？
4. 假设我声明我知道方程 $x^3-2x-4=0$ 的实数解 ~~当然我知道你也可以轻而易举的解出这个方程但是只是举例罢了你就当你不知道吧~~，并且只给你一个定义在循环群 $\lang G\rang$ 上的双线性配对 $e:G\times G\to G$ 以及 $xG$ 的值，你能否在不知道 $x$ 具体值的情况下验证我确实知道上述方程的解？你对双线性配对在 Groth16 中的作用有了什么认识？

一般地，假设三个矩阵各有 $m+1$ 列，即：

$$
A(x)=[a_0(x),\ldots,a_m(x)]\\
B(x)=[b_0(x),\ldots,b_m(x)]\\
C(x)=[c_0(x),\ldots,c_m(x)]\\
\overrightarrow v=(1,v_1,\ldots,v_m)
$$

5. 选取随机数 $\alpha,\beta$，证明下列等式与原来的整除关系等价：

$$
\bigg(\alpha+\displaystyle\sum_{i=0}^mv_ia_i(x)\bigg)\bigg(\beta+\displaystyle\sum_{i=0}^mv_ib_i(x)\bigg)=\alpha\beta+\displaystyle\sum_{i=0}^mv_i(\beta a_i(x)+\alpha b_i(x)+c_i(x))+z(x)h(x)
$$

其中$z(x)=\displaystyle\prod_{i=0}^m(x-i),h(x)=\dfrac{\textstyle\sum_{i=0}^mv_ia_i(x)\textstyle\sum_{i=0}^mv_ib_i(x)-\textstyle\sum_{i=0}^mv_ic_i(x)}{z(x)}$
6. 记 $A=\alpha+\displaystyle\sum_{i=0}^mv_ia_i(x),B=\beta+\displaystyle\sum_{i=0}^mv_ib_i(x)$，如果将 $B$ 中的 $v_i$ 换成另一套向量 $v_i'$，等式能否成立？所以，随机数 $\alpha,\beta$ 有什么作用？

最终 Groth16 协议是长这样的：
$\kern{1.67 em}$选取定义域在群 $\lang G_1\rang,\lang G_2\rang$ 上的双线性配对 $e$，生成随机数 $\alpha,\beta,\gamma,\delta$ 并计算它们与 $G_1,G_2$ 的倍点运算，以及为计算下述验证等式所需的其它必要的倍点运算（这些倍点运算的结果称为公共参考串 CRS），然后销毁这几个随机数，再选取随机数 $r,s$。
暴露的离散对数点为：
$$
[A]_1=(\alpha+\displaystyle\sum_{i=0}^m v_i a_i(x)+r\delta)\cdot G_1
$$
$$
[B]_2=(\beta+\displaystyle\sum_{i=0}^m v_i b_i(x)+s\delta)\cdot G_2
$$
$$
[C]_1=\bigg(\dfrac{\textstyle\sum_{i=\ell+1}^m v_i(\beta a_i(x)+\alpha b_i(x)+c_i(x))+h(x)z(x)}{\delta}+As+Br-rs\delta\bigg)\cdot G_1
$$
验证者根据 CRS 和三个离散对数点以及 $v_0,\ldots,v_\ell$ 验证等式：

$$
e([A]_1,[B]_2)\overset{?}{=}e(\alpha G_1,\beta G_2)\cdot e([C]_1,\delta G_2)\cdot e\bigg(\displaystyle\sum_{i=0}^\ell v_i\dfrac{\beta a_i(x)+\alpha b_i(x)+c_i(x)}{\gamma}G_1,\gamma G_2\bigg)
$$

7. 证明：若以上等式成立，则原来的整除关系必成立（完备性）。
8. 证明：若原来的整除关系成立，则以上等式必成立（一致性）。
9. 搜索并简要说明随机数 $r,s$ 的作用。
10. 你可能注意到， $\delta$ 与多项式的 $\ell+1$ 到 $m$ 项相绑定，而 $\gamma$ 与多项式的 $0$ 到 $\ell$ 项相绑定。假设 $\gamma,\delta$ 均等于1，若证明者不知道 $v_{\ell+1},\ldots,v_m$ 中的至少一项，他能否构造一个伪造的证明？所以，随机数 $\gamma,\delta$ 有什么作用？

## 后记

$\kern{1.67 em}$“真是一个有趣的梦啊。”给宇佐见莲子说完梦境世界里的事之后，玛艾露贝莉·赫恩（梅莉）说：“看来密码学在幻想乡也找到了用武之地了。”
$\kern{1.67 em}$“梅莉，你下次进入梦境之前也要学好密码学了呢。”
$\kern{1.67 em}$“密码学是一个挺复杂的学科呢。但是我相信只要我下功夫去学，应该也能有所收获吧。”

> **Comment from the question setter** `@Null314159`
>
> $\kern{1.67 em}$本来看着招新群里面有许多人在聊音游于是想把故事背景改成Arcaea的呢，结果发现不好编故事就放弃了。感觉在每道题目前面塞了一堆废话呢，不过不看那些字应该也能看懂题目内容吧。嘛还是希望各位解题者能解题愉快吧……要是这些私货能让一些车万人在做题时更有动力我就很高兴了（笑）。

# 秘密共享 II (boss)

在简的要求下，帮众给予了人质更多资源，并且也在慢慢减少给赛斯注射的肌肉松弛剂剂量，因此让一些成员感到不满，她意识到未来的任务将会更加复杂和危险。为了应对未来可能遇到的挑战，她决定深入研究更高级的秘密共享方案，比如线性秘密共享方案（LSSS），并且发现了两种新算法：**Lewko-Waters 算法**和**Liu-Cao-Wong 算法**。

1. 学习线性秘密共享方案，了解 Lewko-Waters 算法和 Liu-Cao-Wong 算法，并结合其中一种算法简要描述线性秘密共享方案的过程（最好能列举一个示例）。(15%)

2. 思考 Lewko-Waters 算法是否能直接支持处理 \( (n, t) \) 的门限方案？Liu-Cao-Wong 算法呢？如果不能，请说明理由。(5%)

3. 假设简在另一个任务中为狮山设计了一套访问控制策略，请用上述两种算法分别写出该访问控制策略所生成的 LSSS 矩阵（要有解题过程）。(15%)

4. 在正式要成为亲卫的当天，简被瑞扎的另一个亲卫带到了位于零号空洞的山狮总部「狮巢」，由于没有给简事先准备的机会，简未能带上逃脱空洞所需的物资和万能认证卡。简·杜决定用线性秘密共享方案将关键信息加密发送给三个治安局成员：赛斯、青衣和朱鸢。假如你是简·杜，现在你知道他们的子秘密分别是 23542809282196、-10204678688636 和 -01246723411451，请你恢复明文，找到逃离空洞所需的关键信息。（注：简使用的是 Lewko-Waters 算法生成的 LSSS 矩阵，并且她将每个字母在字母表中的数字顺序代替字母，再将其连接在一起，比如 a 对应 01，k 对应 11，ak 对应 0111。要有解题过程，确保全部都是小写字母且无空格）(15%)

# 安全证明 II (boss)

1.请你学习安全证明相关知识，理解算法的安全模型和其困难问题之间的联系，并根据自身的理解简单说说如何对一个密码学算法进行安全证明。

2.请根据你的理解说说为什么在构造了Real Scheme后又需要构造Simulated Scheme，它们在整个安全证明过程中是怎样的关系。

3.在安全证明中Real Scheme和Simulated Scheme需要不可区分(Indistinguishable)，请你说说如果敌手A可区分它们会产生什么样的问题。

4.请你学习BLS数字签名的安全性证明，在该证明中敌手选中我们所需消息$m_i$产生其签名的概率非常小，请说说为什么其还是成功的安全证明。

5.请根据所学安全证明的知识和上面几题对你的启发对Elgamal算法进行完整的安全证明，在证明过程中写下自己的思路和理解(Hint: **DDH问题**，**Game Hopping Advantage**)

# 参考链接

2.02 09/23 Ulc:/ g@B.TY 顶级阳谋！如何在全世界的眼皮子底下安全密谋？ 世界上的顶级阳谋，藏在各种网络机制的设计上~# ai新星计划 # 计算机 # ai # 科普 # 动画 https://v.douyin.com/zJ2_DVSkbkg/ 复制此链接，打开Dou音搜索，直接观看视频！

[Why does my SSH private key still work after changing some bytes in the file?](https://crypto.stackexchange.com/questions/31807/why-does-my-ssh-private-key-still-work-after-changing-some-bytes-in-the-file)

[SSH-Keygen 中生成的 Randomart Image 是什么？](https://lpd-ios.github.io/2017/03/27/SSH-Keygen/)
